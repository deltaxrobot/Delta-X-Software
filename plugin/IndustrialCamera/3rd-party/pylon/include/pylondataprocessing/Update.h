//------------------------------------------------------------------------------
//  Basler Data Processing SDK
//  Copyright (c) 2021-2024 Basler AG
//  http://www.baslerweb.com
//  Author:  AG, BR
//------------------------------------------------------------------------------
/*!
 \file

 \brief
    Contains the CUpdate class that can be used to check which output data has been generated by which \c CRecipe data update operation and what the corresponding input data is.
*/

#pragma once

#include <pylon/stdinclude.h>

#include <pylondataprocessing/PylonDataProcessing.h>

#ifdef _MSC_VER
#   pragma pack(push, PYLON_PACKING)
#endif /* _MSC_VER */

namespace Pylon
{
    namespace DataProcessing
    {
        /*!
         \brief
            The \c CUpdate class can be used to check which output data has been generated by which \c CRecipe data update operation and what the corresponding input data is.

         The pylon recipe uses the concept of updates. An update can consist of the synchronized processing of a defined set of data by one or more vTools at the same time. Some vTools can trigger updates on their own, e.g., when
         triggered by a preceding update. This causes a chain of updates.

         \threading
            The CUpdate class isn't thread-safe.
        */
        class PYLONDATAPROCESSING_API CUpdate
        {
        public:
            /*!
             \brief
                Creates a \c CUpdate that can be used as placeholder for assigning a different \c CUpdate object later.

             \post
                 <ul>
                    <li>No data is held.</li>
                    <li>\c IsValid() returns \c false.</li>
                 </ul>

             \error
                Doesn't throw C++ exceptions.
            */
            CUpdate();

            /*!
             \brief
                Destroys a \c CUpdate object.

             \error
                Doesn't throw C++ exceptions.
            */
            virtual ~CUpdate();

            /*!
             \brief
                Copies a \c CUpdate object.

             \param[in]  rhs  The update to copy.

             \post
                 <ul>
                    <li>The update data has been copied.</li>
                 </ul>

             \error
                Doesn't throw C++ exceptions.
            */
            CUpdate(const CUpdate& rhs);

            /*!
             \brief
                Assigns a \c CUpdate.

             \param[in]  rhs  The update to assign.

             \return
                This object.

             \post
                <ul>
                    <li>The update data has been copied.</li>
                </ul>

             \error
                Doesn't throw C++ exceptions.
            */
            CUpdate& operator=(const CUpdate& rhs);

            /*!
             \brief
                Compares a \c CUpdate object.

             \note
                Basler recommends using \c HasBeenTriggeredBy() to find out whether this update is related to another update.

             \param[in] rhs The update to compare to.

             \return
                \c true if this is the same update.

             \error
                Doesn't throw C++ exceptions.
            */
            bool operator==(const CUpdate& rhs) const;

            /*!
             \brief
                Compares a \c CUpdate object.

             \param[in] rhs The update to compare to.

             \return
                \c true if this update has been executed before the \c rhs update. Updates created with the default constructor return \c true if \c rhs is an update created by the recipe.

             \error
                Doesn't throw C++ exceptions.
            */
            bool operator<(const CUpdate& rhs) const;

            /*!
             \brief
                Get the number of updates that directly caused this update.

             \return
                The number of updates that caused this update.

             \error
                Doesn't throw C++ exceptions.
            */
            size_t GetNumPrecedingUpdates() const;

            /*!
             \brief
                Returns the preceding update at the corresponding index.

             \param[in] index The index.

             \return
                The preceding update at the corresponding \c index.

             \pre
                <ul>
                    <li>\c GetNumPrecedingUpdates() returns a value larger than zero.</li>
                    <li>The \c index passed is smaller than the value returned by \c GetNumPrecedingUpdates().</li>
                </ul>

             \error
               Throws an exception if the preconditions aren't met.
            */
            CUpdate GetPrecedingUpdate(size_t index) const;

            /*!
             \brief
                Checks whether the update passed has triggered this update.

             \param[in] rhs The update to compare to.

             \return
                \c true if this update is equal to \c rhs. True if \c rhs is contained in the list of preceding updates.

             \error
                Doesn't throw C++ exceptions.
            */
            bool HasBeenTriggeredBy(const CUpdate& rhs) const;

            /*!
             \brief
                Checks whether the update is valid.

             \return
                \c true if this update is valid.

             \error
                Doesn't throw C++ exceptions.
             */
            bool IsValid() const;

        protected:
            struct UpdateImpl;
            UpdateImpl* m_pImpl;
        };
    }
}

#ifdef _MSC_VER
#   pragma pack(pop)
#endif
