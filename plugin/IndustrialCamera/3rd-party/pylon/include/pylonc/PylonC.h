/*-----------------------------------------------------------------------------
    Basler pylon C SDK
    Copyright (c) 2009-2021 Basler AG
    http://www.baslerweb.com
    Author: AH, TK
-----------------------------------------------------------------------------*/

#ifndef PYLONC_PYLONC_H_
#define PYLONC_PYLONC_H_

/**
    \file
    \brief pylon C bindings
*/


#include <stdio.h> /* for FILENAME_MAX */
#include <genapic/GenApiCDefines.h>

#ifdef GENAPIC_WIN_BUILD
#   ifndef RPC_NO_WINDOWS_H
#       define RPC_NO_WINDOWS_H // otherwise <rpcasync.h> generates warnings on VC6
#       define RPC_NO_WINDOWS_H_DEFINED_BY_PYLONC
#   endif
#   include <windows.h> /* thread api needs windows headers */
#endif
#include <genapic/GenApiC.h>

#include <pylonc/PylonCDefines.h>
#pragma pack(push, PYLONC_PACKING)

#include <pylonc/PylonCError.h>
#include <pylonc/PylonCEnums.h>


#ifdef __cplusplus
// avoid namespace ambiguities between std::_Bool (from yvals.h) and ::_Bool (from GenApiCTypes.h)
#   ifdef _MSC_VER
#       define _Bool ::_Bool
#       define PYLONC_BOOL_DEFINED
#   endif

extern "C" {
#endif /* __cplusplus */

    /** \addtogroup pylon pylon Interface
    * @{
    */

    /* pylon invalid handle type */
#define PYLONC_INVALID_HANDLE GENAPIC_INVALID_HANDLE

/* pylon device access modes */
#define PYLONC_ACCESS_MODE_MONITOR      (0)
#define PYLONC_ACCESS_MODE_CONTROL      (1 << 0)
#define PYLONC_ACCESS_MODE_STREAM       (1 << 1)
#define PYLONC_ACCESS_MODE_EVENT        (1 << 2)
#define PYLONC_ACCESS_MODE_EXCLUSIVE    (1 << 3)

    /* pylon handle types */
    GENAPIC_DECLARE_HANDLE( PYLON_DEVICE_HANDLE );                  /**< \brief A handle for a device object */
    GENAPIC_DECLARE_HANDLE( PYLON_DEVICE_INFO_HANDLE );             /**< \brief A handle for a device info object */
    GENAPIC_DECLARE_HANDLE( PYLON_INTERFACE_HANDLE );               /**< \brief A handle for an interface object */
    GENAPIC_DECLARE_HANDLE( PYLON_INTERFACE_INFO_HANDLE );          /**< \brief A handle for an interface info object */
    GENAPIC_DECLARE_HANDLE( PYLON_STREAMGRABBER_HANDLE );           /**< \brief A handle for a stream grabber object */
    GENAPIC_DECLARE_HANDLE( PYLON_EVENTGRABBER_HANDLE );            /**< \brief A handle for an event grabber object */
    GENAPIC_DECLARE_HANDLE( PYLON_CHUNKPARSER_HANDLE );             /**< \brief A handle for a chunk parser object */
    GENAPIC_DECLARE_HANDLE( PYLON_EVENTADAPTER_HANDLE );            /**< \brief A handle for an event adapter object */
    GENAPIC_DECLARE_HANDLE( PYLON_WAITOBJECT_HANDLE );              /**< \brief A handle for a wait object */
    GENAPIC_DECLARE_HANDLE( PYLON_WAITOBJECTS_HANDLE );             /**< \brief A handle for a node object set */
    GENAPIC_DECLARE_HANDLE( PYLON_STREAMBUFFER_HANDLE );            /**< \brief A handle for a stream buffer object */
    GENAPIC_DECLARE_HANDLE( PYLON_DEVICECALLBACK_HANDLE );          /**< \brief A handle for a device callback object */
    GENAPIC_DECLARE_HANDLE( PYLON_FORMAT_CONVERTER_HANDLE );        /**< \brief A handle for a pixel format converter object */
    GENAPIC_DECLARE_HANDLE( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE );  /**< \brief A handle for a pixel format converter object */
#if defined(GENAPIC_WIN_BUILD)
    GENAPIC_DECLARE_HANDLE( PYLON_AVI_WRITER_HANDLE );              /**< \brief A handle for an AVI writer */
#endif
    GENAPIC_DECLARE_HANDLE( PYLON_IMAGE_DECOMPRESSOR_HANDLE );      /**< \brief A handle for an image decompressor object */

    /** \brief pylon device removal callback handler type. */
    typedef void PYLONC_CC PylonDeviceRemCb_t( PYLON_DEVICE_HANDLE h );


    /** \brief Result data struct for PylonStreamGrabberRetrieveResult().
    *   This data describes grab results (typically image data) retrieved from the device.
    *   Some items are optional (marked as "optional") and are only filled in if they are supported by the device.
    **/
    typedef struct tag_PylonGrabResult_t
    {
        const void* Context;                                        /**< Application specific context specified when calling PylonStreamGrabberRegisterBuffer() */
        PYLON_STREAMBUFFER_HANDLE hBuffer;                          /**< Data buffer handle returned when calling PylonStreamGrabberRegisterBuffer() */
        const void* pBuffer;                                        /**< Pointer to the raw data */
        EPylonGrabStatus Status;                                    /**< Result status. check this to check whether the result contains valid data. */
        EPylonPayloadType PayloadType;                              /**< Type of data contained in buffer */
        EPylonPixelType PixelType;                                  /**< Pixel type (if the result contains pixel data) */
        uint64_t TimeStamp;                                         /**< Time stamp generated by the device when filling the result (optional)*/
        int SizeX;                                                  /**< Number of columns, in pixels (only if payload is image data) */
        int SizeY;                                                  /**< Number of rows, in pixels (only if payload is image data) */
        int OffsetX;                                                /**< Starting column, in pixels (only if payload is image data) */
        int OffsetY;                                                /**< Starting row, in pixels (only if payload is image data) */
        int PaddingX;                                               /**< Number of extra data bytes at end of row (only if payload is image data) */
        int PaddingY;                                               /**< Number of extra data bytes at end of image (only if payload is image data) */
        uint64_t PayloadSize;                                       /**< Total payload size, in bytes, pointed to by pBuffer */
        unsigned int ErrorCode;                                     /**< Additional error code in case Status is gst_Failed (optional) */
        uint64_t BlockID;                                           /**< The block ID of the grabbed frame (camera device specific).
                                                                         \par IEEE 1394 Camera Devices
                                                                         The value of block ID is always UINT64_MAX.
                                                                         
                                                                         \par GigE Camera Devices
                                                                         The sequence number starts with 1 and
                                                                         wraps at 65535. The value 0 has a special meaning and indicates
                                                                         that this feature is not supported by the camera.
                                                                         
                                                                         \par USB Camera Devices
                                                                         The sequence number starts with 0 and uses the full 64 Bit range.
                                                                         
                                                                         \attention A block ID of value UINT64_MAX indicates that the Block ID is invalid and must not be used. */
    } PylonGrabResult_t;

    /** \brief Result data struct for PylonEventGrabberRetrieveEvent(). */
    typedef struct tag_PylonEventResult_t
    {
        unsigned char Buffer[576];                                  /**< Raw chunk data which can be passed to PylonChunkParserAttachBuffer() */
        unsigned int ErrorCode;                                     /**< Error code if there was an error retrieving the event data */
    } PylonEventResult_t;

    struct tag_PylonAviCompressionOptions_t;
    typedef struct tag_PylonAviCompressionOptions_t PylonAviCompressionOptions_t;

    /** \brief Holds the image persistence options. */
    typedef struct tag_PylonImagePersistenceOptions_t
    {
        int quality;                                                /**< Can be used to control the quality when saving JPEG images. Valid quality values range from 0 to 100. */
    } PylonImagePersistenceOptions_t;

    /** \brief Optional result structure of PylonGigEIssueActionCommand() and PylonGigEIssueScheduledActionCommand(). */
    typedef struct tag_PylonGigEActionCommandResult_t
    {
        char DeviceAddress[12 + 3 + 1];                             /**< IP address of the device. */
        int32_t Status;                                             /**< GigE Vision status code returned by the device. See Pylon::EGigEActionCommandStatus for more information. */
    } PylonGigEActionCommandResult_t;

    /**
    * @}
    */

    
    /*
    * ----------------------------------------------------------------------------
    * Initialization/Deinitialization/Misc functions
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonInitialize( void );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonTerminate( void );

    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonSetProperty( int propertyId, const void* pData, size_t size );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGetProperty( int propertyId, void* pData, size_t* pSize );

    
    /*
    * ----------------------------------------------------------------------------
    * Device factory: device enumeration, device creation
    * ----------------------------------------------------------------------------
    */

    /** \addtogroup pylon pylon Interface
    * @{
    */

    /** \brief Fixed string size for PylonDeviceInfo_t members. */
#define PYLON_MAX_DEVICEINFO_ENTRY_LENGTH 64

    /** \brief Device info struct.
    *
    *   This struct provides general information about the device gathered during enumeration.
    **/
    typedef struct tag_PylonDeviceInfo_t
    {
        char FullName[FILENAME_MAX];                                /**< Full unique device name for identification */
        char FriendlyName[PYLON_MAX_DEVICEINFO_ENTRY_LENGTH];       /**< User friendly device name for display purpose */
        char VendorName[PYLON_MAX_DEVICEINFO_ENTRY_LENGTH];         /**< Manufacturer of the device*/
        char ModelName[PYLON_MAX_DEVICEINFO_ENTRY_LENGTH];          /**< Model name of the device*/
        char SerialNumber[PYLON_MAX_DEVICEINFO_ENTRY_LENGTH];       /**< Serial number of the device */
        char DeviceClass[PYLON_MAX_DEVICEINFO_ENTRY_LENGTH];        /**< The device class (transport layer) used by the device */
        char DeviceVersion[PYLON_MAX_DEVICEINFO_ENTRY_LENGTH];      /**< The device version as reported by the device */
        char UserDefinedName[PYLON_MAX_DEVICEINFO_ENTRY_LENGTH];    /**< User defined name, if present, as reported by the device */
    } PylonDeviceInfo_t;


    /** \brief Fixed string size for PylonInterfaceInfo_t members. */
#define PYLON_MAX_INTERFACEINFO_ENTRY_LENGTH 64

    /** \brief Interface info struct.
    *
    *   This struct provides general information about the interface gathered during enumeration.
    **/
    typedef struct tag_PylonInterfaceInfo_t
    {
        char InterfaceID[PYLON_MAX_INTERFACEINFO_ENTRY_LENGTH];     /**< Interface ID for identification */
        char DeviceClass[PYLON_MAX_INTERFACEINFO_ENTRY_LENGTH];     /**< The device class (transport layer) used by the interface */
        char FriendlyName[PYLON_MAX_INTERFACEINFO_ENTRY_LENGTH];    /**< User friendly interface name for display purpose */
        char TlType[PYLON_MAX_INTERFACEINFO_ENTRY_LENGTH];          /**< Type of transport layer */
    } PylonInterfaceInfo_t;

    /**
    * @}
    */

    /*
    * ----------------------------------------------------------------------------
    * Interface functions
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEnumerateInterfaces( size_t* numInterfaces );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEnumerateInterfacesByDeviceClass( const char* pDeviceClass, size_t* numInterfaces );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGetInterfaceInfo( size_t index, PylonInterfaceInfo_t* pIfInfo );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonCreateInterfaceByIndex( size_t index, PYLON_INTERFACE_HANDLE* phIf );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDestroyInterface( PYLON_INTERFACE_HANDLE hIf );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonInterfaceOpen( PYLON_INTERFACE_HANDLE hIf );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonInterfaceClose( PYLON_INTERFACE_HANDLE hIf );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonInterfaceIsOpen( PYLON_INTERFACE_HANDLE hIf, _Bool* pOpen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonInterfaceGetInterfaceInfo( PYLON_INTERFACE_HANDLE hIf, PylonInterfaceInfo_t* pIfInfo );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonInterfaceGetNodeMap( PYLON_INTERFACE_HANDLE hIf, NODEMAP_HANDLE* phMap );


    /*
    * ----------------------------------------------------------------------------
    * Device enumeration
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEnumerateDevices( size_t* numDevices );


    /*
    * ----------------------------------------------------------------------------
    * GigE Device specific enumeration / creation
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigEEnumerateAllDevices( size_t* numDevices );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigEForceIp( const char* pMacAddress, const char* pIpAddress, const char* pSubnetMask, const char* pDefaultGateway );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigERestartIpConfiguration( const char* pMacAddress );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigEChangeIpConfiguration( PYLON_DEVICE_HANDLE hDev, _Bool EnablePersistentIp, _Bool EnableDhcp );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigESetPersistentIpAddress( PYLON_DEVICE_HANDLE hDev, const char* pIpAddress, const char* pSubnetMask, const char* pDefaultGateway );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigEAnnounceRemoteDevice( const char* pIpAddress );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigERenounceRemoteDevice( const char* pIpAddress, _Bool* pFound );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigEGetPersistentIpAddress( PYLON_DEVICE_HANDLE hDev, char* pIpAddress, size_t* pIpAddressLen, char* pSubnetMask, size_t* pSubnetMaskLen, char* pDefaultGateway, size_t* pDefaultGatewayLen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigEBroadcastIpConfiguration( const char* pMacAddress, _Bool EnablePersistentIp, _Bool EnableDHCP, const char* pIpAddress, const char* pSubnetMask, const char* pDefaultGateway, const char* pUserdefinedName, _Bool* pRetval );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigEIssueActionCommand( uint32_t deviceKey, uint32_t groupKey, uint32_t groupMask, const char* pBroadcastAddress, uint32_t timeoutMs, uint32_t* pNumResults, PylonGigEActionCommandResult_t* pResults );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGigEIssueScheduledActionCommand( uint32_t deviceKey, uint32_t groupKey, uint32_t groupMask, uint64_t actiontimeNs, const char* pBroadcastAddress, uint32_t timeoutMs, uint32_t* pNumResults, PylonGigEActionCommandResult_t* pResults );


    /*
    * ----------------------------------------------------------------------------
    * DeviceInfo
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGetDeviceInfo( size_t index, PylonDeviceInfo_t* pDi );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonGetDeviceInfoHandle( size_t index, PYLON_DEVICE_INFO_HANDLE* phDi );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceInfoGetNumProperties( PYLON_DEVICE_INFO_HANDLE hDi, size_t* numProperties );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceInfoGetPropertyValueByName( PYLON_DEVICE_INFO_HANDLE hDi, const char* pName, char* pValue, size_t* pBufLen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceInfoGetPropertyValueByIndex( PYLON_DEVICE_INFO_HANDLE hDi, size_t index, char* pBuf, size_t* pBufLen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceInfoGetPropertyName( PYLON_DEVICE_INFO_HANDLE hDi, size_t index, char* pName, size_t* pBufLen );


    /*
    * ----------------------------------------------------------------------------
    * Device creation / destruction
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonCreateDeviceByIndex( size_t index, PYLON_DEVICE_HANDLE* phDev );
#if defined(GENAPIC_WIN_BUILD)
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonCreateDeviceFromDirectShowID( int id, PYLON_DEVICE_HANDLE* phDev );
#endif
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDestroyDevice( PYLON_DEVICE_HANDLE hDev );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonIsDeviceAccessible( size_t index, int accessMode, _Bool* pIsAccessible );


    /*
    * ----------------------------------------------------------------------------
    * Device operations
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceOpen( PYLON_DEVICE_HANDLE hDev, int accessMode );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceClose( PYLON_DEVICE_HANDLE hDev );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceIsOpen( PYLON_DEVICE_HANDLE hDev, _Bool* pOpen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceAccessMode( PYLON_DEVICE_HANDLE hDev, int* pAccessMode );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetDeviceInfo( PYLON_DEVICE_HANDLE hDev, /* */ PylonDeviceInfo_t* pDeviceInfo );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetDeviceInfoHandle( PYLON_DEVICE_HANDLE hDev, PYLON_DEVICE_INFO_HANDLE* phDi );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetNumStreamGrabberChannels( PYLON_DEVICE_HANDLE hDev, size_t* pNumChannels );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetStreamGrabber( PYLON_DEVICE_HANDLE hDev, size_t index, PYLON_STREAMGRABBER_HANDLE* phStg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetEventGrabber( PYLON_DEVICE_HANDLE hDev, PYLON_EVENTGRABBER_HANDLE* phEvg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetNodeMap( PYLON_DEVICE_HANDLE hDev, NODEMAP_HANDLE* phMap );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetTLNodeMap( PYLON_DEVICE_HANDLE hDev, NODEMAP_HANDLE* phMap );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceCreateChunkParser( PYLON_DEVICE_HANDLE hDev, PYLON_CHUNKPARSER_HANDLE* phChp );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceDestroyChunkParser( PYLON_DEVICE_HANDLE hDev, PYLON_CHUNKPARSER_HANDLE hChp );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceCreateEventAdapter( PYLON_DEVICE_HANDLE hDev, PYLON_EVENTADAPTER_HANDLE* phEva );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceDestroyEventAdapter( PYLON_DEVICE_HANDLE hDev, PYLON_EVENTADAPTER_HANDLE hEva );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceRegisterRemovalCallback( PYLON_DEVICE_HANDLE hDev, PylonDeviceRemCb_t* pCbFunction, PYLON_DEVICECALLBACK_HANDLE* phCb );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceDeregisterRemovalCallback( PYLON_DEVICE_HANDLE hDev, PYLON_DEVICECALLBACK_HANDLE hCb );


    /*
    * ----------------------------------------------------------------------------
    * Device convenience methods to access the device node map
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceSetIntegerFeature( PYLON_DEVICE_HANDLE hDev, const char* pName, int64_t value );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetIntegerFeature( PYLON_DEVICE_HANDLE hDev, const char* pName, int64_t* pValue );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetIntegerFeatureMin( PYLON_DEVICE_HANDLE hDev, const char* pName, int64_t* pValue );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetIntegerFeatureMax( PYLON_DEVICE_HANDLE hDev, const char* pName, int64_t* pValue );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetIntegerFeatureInc( PYLON_DEVICE_HANDLE hDev, const char* pName, int64_t* pValue );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGrabSingleFrame( PYLON_DEVICE_HANDLE hDev, size_t channel, void* pBuffer, size_t bufferSize, PylonGrabResult_t* pGrabResult, _Bool* pReady, uint32_t timeout );

    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceSetFloatFeature( PYLON_DEVICE_HANDLE hDev, const char* pName, double value );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetFloatFeature( PYLON_DEVICE_HANDLE hDev, const char* pName, double* pValue );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetFloatFeatureMin( PYLON_DEVICE_HANDLE hDev, const char* pName, double* pValue );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetFloatFeatureMax( PYLON_DEVICE_HANDLE hDev, const char* pName, double* pValue );

    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceSetBooleanFeature( PYLON_DEVICE_HANDLE hDev, const char* pName, _Bool value );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceGetBooleanFeature( PYLON_DEVICE_HANDLE hDev, const char* pName, _Bool* pValue );

    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceExecuteCommandFeature( PYLON_DEVICE_HANDLE hDev, const char* pName );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceIsCommandDone( PYLON_DEVICE_HANDLE hDev, const char* pName, _Bool* pResult );

    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceFeatureFromString( PYLON_DEVICE_HANDLE hDev, const char* pName, const char* pValue );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonDeviceFeatureToString( PYLON_DEVICE_HANDLE hDev, const char* pName, char* pBuf, size_t* pBufLen );

    PYLONC_API _Bool PYLONC_CC PylonDeviceFeatureIsImplemented( PYLON_DEVICE_HANDLE hDev, const char* pName );
    PYLONC_API _Bool PYLONC_CC PylonDeviceFeatureIsAvailable( PYLON_DEVICE_HANDLE hDev, const char* pName );
    PYLONC_API _Bool PYLONC_CC PylonDeviceFeatureIsReadable( PYLON_DEVICE_HANDLE hDev, const char* pName );
    PYLONC_API _Bool PYLONC_CC PylonDeviceFeatureIsWritable( PYLON_DEVICE_HANDLE hDev, const char* pName );
    PYLONC_API GENAPIC_RESULT GENAPIC_CC PylonDeviceFeatureGetAccessMode( PYLON_DEVICE_HANDLE hDev, const char* pName, EGenApiAccessMode* pResult );


    /*
    * ----------------------------------------------------------------------------
    * Stream grabber operations
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberOpen( PYLON_STREAMGRABBER_HANDLE hStg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberClose( PYLON_STREAMGRABBER_HANDLE hStg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberIsOpen( PYLON_STREAMGRABBER_HANDLE hStg, _Bool* pOpen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberGetWaitObject( PYLON_STREAMGRABBER_HANDLE hStg, PYLON_WAITOBJECT_HANDLE* phWobj );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberSetMaxNumBuffer( PYLON_STREAMGRABBER_HANDLE hStg, size_t numBuffers );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberGetMaxNumBuffer( PYLON_STREAMGRABBER_HANDLE hStg, size_t* pNumBuffers );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberSetMaxBufferSize( PYLON_STREAMGRABBER_HANDLE hStg, size_t maxSize );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberGetMaxBufferSize( PYLON_STREAMGRABBER_HANDLE hStg, size_t* pMaxSize );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberGetPayloadSize( PYLON_DEVICE_HANDLE hDev, PYLON_STREAMGRABBER_HANDLE hStg, size_t* payloadsize );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberRegisterBuffer( PYLON_STREAMGRABBER_HANDLE hStg, void* pBuffer, size_t BufLen, PYLON_STREAMBUFFER_HANDLE* phBuf );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberDeregisterBuffer( PYLON_STREAMGRABBER_HANDLE hStg, PYLON_STREAMBUFFER_HANDLE hBuf );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberPrepareGrab( PYLON_STREAMGRABBER_HANDLE hStg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberIsStartAndStopStreamingMandatory( PYLON_STREAMGRABBER_HANDLE hStg, _Bool* pMandatory );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberStartStreamingIfMandatory( PYLON_STREAMGRABBER_HANDLE hStg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberStopStreamingIfMandatory( PYLON_STREAMGRABBER_HANDLE hStg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberFinishGrab( PYLON_STREAMGRABBER_HANDLE hStg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberFlushBuffersToOutput( PYLON_STREAMGRABBER_HANDLE hStg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberCancelGrab( PYLON_STREAMGRABBER_HANDLE hStg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberRetrieveResult( PYLON_STREAMGRABBER_HANDLE hStg, PylonGrabResult_t* pGrabResult, _Bool* pReady );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberQueueBuffer( PYLON_STREAMGRABBER_HANDLE hStg, PYLON_STREAMBUFFER_HANDLE hBuf, const void* pContext );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonStreamGrabberGetNodeMap( PYLON_STREAMGRABBER_HANDLE hStg, NODEMAP_HANDLE* phMap );


    /*
    * ----------------------------------------------------------------------------
    * Wait object
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectIsValid( PYLON_WAITOBJECT_HANDLE hWobj, _Bool* pValid );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectWait( PYLON_WAITOBJECT_HANDLE hWobj, uint32_t timeout, _Bool* pResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectWaitEx( PYLON_WAITOBJECT_HANDLE hWobj, uint32_t timeout, _Bool alertable, EPylonWaitExResult* pWaitResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectCreate( PYLON_WAITOBJECT_HANDLE* phWobj );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectDestroy( PYLON_WAITOBJECT_HANDLE hWobj );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectSignal( PYLON_WAITOBJECT_HANDLE hWobj );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectReset( PYLON_WAITOBJECT_HANDLE hWobj );

#if defined(GENAPIC_LINUX_BUILD)
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectFromFd( int fd, PYLON_WAITOBJECT_HANDLE* phWobj );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectGetFd( PYLON_WAITOBJECT_HANDLE hWobj, int* pFd );
#elif defined(GENAPIC_WIN_BUILD)
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectFromW32( HANDLE hW32, _Bool duplicate, PYLON_WAITOBJECT_HANDLE* phWobj );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectGetW32Handle( PYLON_WAITOBJECT_HANDLE hWobj, PHANDLE phW32 );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonRTThreadGetPriorityCapabilities( int32_t* pPriorityMin, int32_t* pPriorityMax );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonRTThreadSetPriority( HANDLE hThread, int32_t priority );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonRTThreadGetPriority( HANDLE hThread, int32_t* pPriority );
#endif /* GENAPIC_WIN_BUILD */

    /*
    * ----------------------------------------------------------------------------
    * Wait objects
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsCreate( PYLON_WAITOBJECTS_HANDLE* phWos );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsDestroy( PYLON_WAITOBJECTS_HANDLE hWos );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsAdd( PYLON_WAITOBJECTS_HANDLE hWos, PYLON_WAITOBJECT_HANDLE hWobj, size_t* pIndex );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsAddMany( PYLON_WAITOBJECTS_HANDLE hWos, size_t numWaitObjects, ... );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsRemoveAll( PYLON_WAITOBJECTS_HANDLE hWos );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsWaitForAll( PYLON_WAITOBJECTS_HANDLE hWos, uint32_t timeout, _Bool* pResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsWaitForAny( PYLON_WAITOBJECTS_HANDLE hWos, uint32_t timeout, size_t* pIndex, _Bool* pResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsWaitForAny( PYLON_WAITOBJECTS_HANDLE hWos, uint32_t timeout, size_t* pIndex, _Bool* pResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsWaitForAllEx( PYLON_WAITOBJECTS_HANDLE hWos, uint32_t timeout, _Bool alertable, EPylonWaitExResult* pWaitResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonWaitObjectsWaitForAnyEx( PYLON_WAITOBJECTS_HANDLE hWos, uint32_t timeout, size_t* pIndex, _Bool alertable, EPylonWaitExResult* pWaitResult );


    /*
    * ----------------------------------------------------------------------------
    * Event grabber
    * ----------------------------------------------------------------------------
    */
    extern PYLONC_API const size_t PylonEventGrabberBufferSize;
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEventGrabberOpen( PYLON_EVENTGRABBER_HANDLE hEvg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEventGrabberClose( PYLON_EVENTGRABBER_HANDLE hEvg );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEventGrabberIsOpen( PYLON_EVENTGRABBER_HANDLE hEvg, _Bool* pOpen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEventGrabberRetrieveEvent( PYLON_EVENTGRABBER_HANDLE hEvg, PylonEventResult_t* pEventResult, _Bool* pReady );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEventGrabberGetWaitObject( PYLON_EVENTGRABBER_HANDLE hEvg, PYLON_WAITOBJECT_HANDLE* phWobj );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEventGrabberGetNodeMap( PYLON_EVENTGRABBER_HANDLE hEvg, NODEMAP_HANDLE* phMap );


    /*
    * ----------------------------------------------------------------------------
    * Event grabber convenience methods
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEventGrabberGetNumBuffers( PYLON_EVENTGRABBER_HANDLE hEvg, size_t* pNumBuffers );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEventGrabberSetNumBuffers( PYLON_EVENTGRABBER_HANDLE hEvg, size_t numBuffers );


    /*
    * ----------------------------------------------------------------------------
    * Event adapter
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonEventAdapterDeliverMessage( PYLON_EVENTADAPTER_HANDLE hEva, const PylonEventResult_t* pEventResult );


    /*
    * ----------------------------------------------------------------------------
    * Chunk parser
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonChunkParserAttachBuffer( PYLON_CHUNKPARSER_HANDLE hChp, const void* pBuffer, size_t BufLen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonChunkParserDetachBuffer( PYLON_CHUNKPARSER_HANDLE hChp );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonChunkParserUpdateBuffer( PYLON_CHUNKPARSER_HANDLE hChp, const void* pBuffer );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonChunkParserHasCRC( PYLON_CHUNKPARSER_HANDLE hChp, _Bool* pResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonChunkParserCheckCRC( PYLON_CHUNKPARSER_HANDLE hChp, _Bool* pResult );


    /*
    * ----------------------------------------------------------------------------
    * Deprecated PixelFormat functions. Use ImageFormat functions instead.
    * ----------------------------------------------------------------------------
    */
    /* Deprecated: PylonPixelFormatConverterCreate has been deprecated. Use PylonImageFormatConverterCreate instead. */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonPixelFormatConverterCreate( PYLON_DEVICE_HANDLE hDev, int outAlign, PYLON_FORMAT_CONVERTER_HANDLE* phConv );
    /* Deprecated: PylonPixelFormatConverterConvert has been deprecated. Use PylonImageFormatConverterConvert instead. */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonPixelFormatConverterConvert( PYLON_FORMAT_CONVERTER_HANDLE hConv, void* targetBuffer, size_t targetBufferSize, const void* sourceBuffer, size_t sourceBufferSize );
    /* Deprecated: PylonPixelFormatConverterGetOutputBufferSize has been deprecated. Use PylonImageFormatConverterGetBufferSizeForConversion instead. */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonPixelFormatConverterGetOutputBufferSize( PYLON_FORMAT_CONVERTER_HANDLE hConv, size_t* pBufSiz );
    /* Deprecated: PylonPixelFormatConverterDestroy has been deprecated. Use PylonImageFormatConverterDestroy instead. */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonPixelFormatConverterDestroy( PYLON_FORMAT_CONVERTER_HANDLE hConv );


    /*
    * ----------------------------------------------------------------------------
    * Pixel Type operations
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonBitsPerPixel( EPylonPixelType pixelType, int* pResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonIsMono( EPylonPixelType pixelType, _Bool* pResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonIsBayer( EPylonPixelType pixelType, _Bool* pResult );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonPixelTypeFromString( const char* pString, EPylonPixelType* pPixelType );



    /*
    * ----------------------------------------------------------------------------
    * Port read and write operations
    * ----------------------------------------------------------------------------
    */
    GENAPIC_API GENAPIC_RESULT GENAPIC_CC PylonDevicePortRead( PYLON_DEVICE_HANDLE hDev, void* pBuffer, int64_t Address, size_t Length );
    GENAPIC_API GENAPIC_RESULT GENAPIC_CC PylonDevicePortWrite( PYLON_DEVICE_HANDLE hDev, const void* pBuffer, int64_t Address, size_t Length );


    /*
    * ----------------------------------------------------------------------------
    * Feature Persistence
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonFeaturePersistenceSave( NODEMAP_HANDLE hMap, const char* pFileName );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonFeaturePersistenceLoad( NODEMAP_HANDLE hMap, const char* pFileName, _Bool verify );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonFeaturePersistenceSaveToString( NODEMAP_HANDLE hMap, char* pFeatures, size_t* pFeaturesLen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonFeaturePersistenceLoadFromString( NODEMAP_HANDLE hMap, const char* pFeatures, _Bool verify );


    /*
    * ----------------------------------------------------------------------------
    * Image Persistence
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImagePersistenceSave( EPylonImageFileFormat imageFileFormat, const char* pFilename, const void* pBuffer, size_t bufferSize, EPylonPixelType pixelType, uint32_t width, uint32_t height, size_t paddingX, EPylonImageOrientation orientation, PylonImagePersistenceOptions_t* pOptions );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImagePersistenceLoad( const char* pFilename, void* pBuffer, size_t* pBufferSize, EPylonPixelType* pPixelType, uint32_t* pWidth, uint32_t* pHeight, size_t* pPaddingX, EPylonImageOrientation* pOrientation );


    /*
    * ----------------------------------------------------------------------------
    * Image Format Converter
    * ----------------------------------------------------------------------------
    */
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageFormatConverterCreate( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE* phConv );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageFormatConverterGetNodeMap( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE hConv, NODEMAP_HANDLE* phMap );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageFormatConverterSetOutputPixelFormat( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE hConv, EPylonPixelType pixelType );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageFormatConverterGetOutputPixelFormat( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE hConv, EPylonPixelType* pPixelType );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageFormatConverterSetOutputPaddingX( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE hConv, size_t paddingX );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageFormatConverterGetOutputPaddingX( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE hConv, size_t* pPaddingX );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageFormatConverterConvert( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE hConv, void* targetBuffer, size_t targetBufferSize, const void* sourceBuffer, size_t sourceBufferSize, EPylonPixelType sourcePixelType, uint32_t sourceWidth, uint32_t sourceHeight, size_t sourcePaddingX, EPylonImageOrientation sourceOrientation );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageFormatConverterGetBufferSizeForConversion( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE hConv, EPylonPixelType sourcePixelType, uint32_t sourceWidth, uint32_t sourceHeight, size_t* pBufSize );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageFormatConverterDestroy( PYLON_IMAGE_FORMAT_CONVERTER_HANDLE hConv );


    /*
    * ----------------------------------------------------------------------------
    * Avi Writer
    * ----------------------------------------------------------------------------
    */
#if defined(GENAPIC_WIN_BUILD)
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonAviWriterCreate( PYLON_AVI_WRITER_HANDLE* phWriter );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonAviWriterDestroy( PYLON_AVI_WRITER_HANDLE hWriter );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonAviWriterOpen( PYLON_AVI_WRITER_HANDLE hWriter, const char* pFilename, double framesPerSecondPlayback, EPylonPixelType pixelType, uint32_t width, uint32_t height, EPylonImageOrientation orientation, PylonAviCompressionOptions_t* pCompressionOptions );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonAviWriterClose( PYLON_AVI_WRITER_HANDLE hWriter );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonAviWriterIsOpen( PYLON_AVI_WRITER_HANDLE hWriter, _Bool* pIsOpen );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonAviWriterAdd( PYLON_AVI_WRITER_HANDLE hWriter, const void* pBuffer, size_t bufferSize, EPylonPixelType pixelType, uint32_t width, uint32_t height, size_t paddingX, EPylonImageOrientation orientation, EPylonKeyFrameSelection keyFrameSelection );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonAviWriterCanAddWithoutConversion( PYLON_AVI_WRITER_HANDLE hWriter, EPylonPixelType pixelType, uint32_t width, uint32_t height, size_t paddingX, EPylonImageOrientation orientation, _Bool* pCanAddWithoutConversion );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonAviWriterGetImageDataBytesWritten( PYLON_AVI_WRITER_HANDLE hWriter, size_t* pImageDataBytesWritten );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonAviWriterGetCountOfAddedImages( PYLON_AVI_WRITER_HANDLE hWriter, size_t* pCountOfAddedImages );
#endif


    /*
    * ----------------------------------------------------------------------------
    * Image Window
    * ----------------------------------------------------------------------------
    */
    /* */
#if defined(GENAPIC_WIN_BUILD)
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageWindowCreate( size_t winIndex, int x, int y, int nWidth, int nHeight );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageWindowShow( size_t winIndex, int nShow );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageWindowHide( size_t winIndex );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageWindowClose( size_t winIndex );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageWindowGetWindowHandle( size_t winIndex, HWND* phWindow );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageWindowSetImage( size_t winIndex, const void* buffer, size_t bufferSize, EPylonPixelType pixelType, uint32_t width, uint32_t height, size_t paddingX, EPylonImageOrientation orientation );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageWindowDisplayImage( size_t winIndex, const void* buffer, size_t bufferSize, EPylonPixelType pixelType, uint32_t width, uint32_t height, size_t paddingX, EPylonImageOrientation orientation );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageWindowDisplayImageGrabResult( size_t winIndex, PylonGrabResult_t* grabResult );
#endif


    /*
    * ----------------------------------------------------------------------------
    * Image Decompressor
    * ----------------------------------------------------------------------------
    */

    /** \brief The struct containing information about a grab buffer/result.

        If the hasCompressedImage field in the struct is true, the grab buffer/result
        contains a compressed image. In this case, you should check the compressionStatus
        field in the struct to check whether the camera was able to compress
        the image properly. The camera can't compress an image if the amount of
        data required for compressing the image exceeds the desired compression ratio.
        The image can be decompressed if compressionStatus is CompressionStatus_Ok.
        If the hasCompressedImage field in the struct is false, the grab buffer/result
        already contains a decompressed image. In this case, the decompressedImageSize
        and decompressedPayloadSize fields will not be used. All other fields contain
        information about the decompressed data.
    **/
    typedef struct tag_PylonCompressionInfo_t
    {
        _Bool HasCompressedImage;                                   /**< True if grab buffer/result provided contains a compressed image (otherwise false if buffer/result is already decompressed). */
        EPylonCompressionStatus CompressionStatus;                  /**< Status of compression (see EPylonCompressionStatus). */
        _Bool Lossy;                                                /**< True if image was compressed lossily (otherwise false if it was compressed losslessly). */
        EPylonPixelType PixelType;                                  /**< Pixel type of compressed image. */
        int SizeX;                                                  /**< Width (in pixels) of compressed image. */
        int SizeY;                                                  /**< Height (in pixels) of compressed image. */
        int OffsetX;                                                /**< X offset (in pixels) of compressed image. */
        int OffsetY;                                                /**< Y offset (in pixels) of compressed image. */
        int PaddingX;                                               /**< X padding (line padding; in bytes) of compressed image. */
        int PaddingY;                                               /**< Y padding (image padding; in bytes) of compressed image. */
        size_t DecompressedImageSize;                               /**< Size (in bytes) required for the decompressed image (only valid if hasCompressedImage is true). */
        size_t DecompressedPayloadSize;                             /**< Size (in bytes; including chunk data) required for the decompressed payload (only valid if hasCompressedImage is true). */
    } PylonCompressionInfo_t;

    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageDecompressorCreate( PYLON_IMAGE_DECOMPRESSOR_HANDLE* phDecompressor );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageDecompressorDestroy( PYLON_IMAGE_DECOMPRESSOR_HANDLE hDecompressor );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageDecompressorSetCompressionDescriptor( PYLON_IMAGE_DECOMPRESSOR_HANDLE hDecompressor, const void* pCompressionDescriptor, size_t sizeCompressionDescriptor );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageDecompressorGetCompressionInfo( const void* pPayload, size_t payloadSize, PylonCompressionInfo_t* pCompressionInfo );
    PYLONC_API GENAPIC_RESULT PYLONC_CC PylonImageDecompressorDecompressImage( PYLON_IMAGE_DECOMPRESSOR_HANDLE hDecompressor, void* pOutputBuffer, size_t* pOutputBufferSize, const void* pPayload, size_t payloadSize, PylonCompressionInfo_t* pCompressionInfo );


#ifdef __cplusplus
} /* extern "C" */
#   ifdef PYLONC_BOOL_DEFINED
#       undef _Bool
#       undef PYLONC_BOOL_DEFINED
#   endif
#endif /* __cplusplus */

#include <pylonc/PylonC32BitMethods.h>

/* undefine macros defined by this header */
#if defined(RPC_NO_WINDOWS_H_DEFINED_BY_PYLONC)
#   undef RPC_NO_WINDOWS_H_DEFINED_BY_PYLONC
#   undef RPC_NO_WINDOWS_H
#endif

#pragma pack(pop)

#endif /* PYLONC_PYLONC_H_ */
